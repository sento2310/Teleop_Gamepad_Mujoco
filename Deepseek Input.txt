config.py:

"""
Centralized configuration for the teleoperation system.
Holds global settings accessible by all modules.
"""

# Robot configurations
ROBOT_CONFIGS = {
    'panda': {
        'name': 'Franka Emika Panda',
        'xml_path': 'franka_emika_panda/panda.xml',
        'end_effector_body': 'hand',
        'arm_joint_count': 7,
        'axis_remap': {
            'vx': 'vx', 'vy': 'vy', 'vz': 'vz',
            'roll': 'roll', 'pitch': 'pitch', 'yaw': 'yaw'
        },
        'movement_scales': {
            'translation': 0.3, 'rotation': 0.5, 'tilt': 0.5,
            'gripper_open_pos': 1.0, 'gripper_close_pos': 0.0,
            'gripper_speed': 1, 'deadzone_threshold': 0.1
        }
    },
    'ur5': {
        'name': 'UR5e with 2F-85 Gripper',
        'xml_path': 'universal_robots_ur5e/ur5e_with_gripper.xml',
        'end_effector_body': 'robotiq_base',
        'arm_joint_count': 6,
        'axis_remap': {
            'vx': 'vx', 'vy': 'vy', 'vz': 'vz',
            'roll': 'roll', 'pitch': 'pitch', 'yaw': 'yaw'
        },
        'movement_scales': {
            'translation': 0.2, 'rotation': 0.3, 'tilt': 0.3,
            'gripper_open_pos': 1.0, 'gripper_close_pos': 0.0,
            'gripper_speed': 1, 'deadzone_threshold': 0.1
        }
    },
    'so100': {
        'name': 'SO100 Robotic Arm',
        'xml_path': 'trs_so_arm100/so_arm100.xml',
        'end_effector_body': 'Fixed_Jaw',
        'arm_joint_count': 5,
        'axis_remap': {
            'vx': 'vy', 'vy': 'vz', 'vz': 'vx',  # Axis swapping
            'roll': 'pitch', 'pitch': 'yaw', 'yaw': 'roll'
        },
        'movement_scales': {
            'translation': 0.15, 'rotation': 0.4, 'tilt': 0.4,
            'gripper_open_pos': 0.0123, 'gripper_close_pos': 0.0,
            'gripper_speed': 1, 'deadzone_threshold': 0.1
        },
        'joint_multipliers': {
            'rotation': 0.005, 'wrist_roll': 0.01, 'wrist_pitch': 0.02,
            'pitch': 1.0, 'elbow': 1.0
        }
    }
}

def get_robot_config(robot_name):
    """@brief Get configuration for a specific robot"""
    if robot_name not in ROBOT_CONFIGS:
        available = list(ROBOT_CONFIGS.keys())
        raise ValueError(f"Robot '{robot_name}' not found. Available: {available}")
    return ROBOT_CONFIGS[robot_name].copy()

def get_movement_scales(robot_name):
    """@brief Get movement scales for specified robot"""
    config = get_robot_config(robot_name)
    return config.get('movement_scales', {
        'translation': 0.2, 'rotation': 0.3, 'tilt': 0.3,
        'gripper_open_pos': 1.0, 'gripper_close_pos': 0.0,
        'gripper_speed': 1, 'deadzone_threshold': 0.1
    })

def get_joint_multipliers(robot_name):
    """@brief Get joint control multipliers for specified robot"""
    config = get_robot_config(robot_name)
    return config.get('joint_multipliers', {
        'rotation': 1.0, 'wrist_roll': 1.0, 'wrist_pitch': 1.0,
        'pitch': 1.0, 'elbow': 1.0
    })



gamepad_control.py:

"""
Gamepad Control Launcher for Robotic Arm Teleoperation.
Provides a unified entry point for all robot control systems.
"""

import sys
import os

# Add the current directory to Python path to import modules
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

from genericteleoperation import GenericTeleoperation
from so100teleoperation import SO100Teleoperation
from config import get_robot_config


class GamepadControlLauncher:
    """
    Main launcher class for robotic arm teleoperation systems.
    Handles robot selection and system initialization.
    """

    def __init__(self):
        """@brief Initialize the gamepad control launcher"""
        self.available_robots = ['panda', 'ur5', 'so100']
        self.selected_robot = None
        self.teleop_system = None

    def select_robot(self, robot_name):
        """
        @brief Select and validate the robot for teleoperation
        @param robot_name: Name of the robot to control
        @return: True if selection is valid, False otherwise
        """
        if robot_name not in self.available_robots:
            print(f"Error: Robot '{robot_name}' not available.")
            print(f"Available robots: {', '.join(self.available_robots)}")
            return False

        self.selected_robot = robot_name
        robot_config = get_robot_config(robot_name)
        print(f"Selected robot: {robot_config['name']}")
        return True

    def initialize_teleop_system(self):
        """
        @brief Initialize the appropriate teleoperation system
        @return: True if initialization successful, False otherwise
        """
        if not self.selected_robot:
            print("Error: No robot selected. Please call select_robot() first.")
            return False

        try:
            if self.selected_robot == 'so100':
                # Use SO100-specific teleoperation
                from so100teleoperation import SO100Teleoperation
                self.teleop_system = SO100Teleoperation()
                print("Initialized SO100 teleoperation system")
            else:
                # Use generic teleoperation for Panda/UR5
                from genericteleoperation import GenericTeleoperation
                self.teleop_system = GenericTeleoperation(robot_name=self.selected_robot)
                print(f"Initialized Generic teleoperation system for {self.selected_robot}")

            return True

        except ImportError as e:
            print(f"Error importing teleoperation module: {e}")
            return False
        except Exception as e:
            print(f"Error initializing teleoperation system: {e}")
            return False

    def run(self):
        """@brief Run the selected teleoperation system"""
        if not self.teleop_system:
            print("Error: Teleoperation system not initialized.")
            return

        try:
            print(f"\nStarting teleoperation for {self.selected_robot}...")
            print("Press Ctrl+C to exit gracefully")
            print("-" * 50)

            self.teleop_system.run()

        except KeyboardInterrupt:
            print("\nTeleoperation interrupted by user")
        except Exception as e:
            print(f"Error during teleoperation: {e}")
        finally:
            print("Teleoperation session ended.")

    def get_robot_info(self, robot_name):
        """
        @brief Get information about a specific robot
        @param robot_name: Name of the robot
        @return: Robot configuration dictionary or None
        """
        try:
            config = get_robot_config(robot_name)
            return {
                'name': config['name'],
                'description': f"{config['name']} with {config['arm_joint_count']} arm joints",
                'end_effector': config['end_effector_body']
            }
        except:
            return None


def main():
    """@brief Main function - entry point for gamepad control"""
    launcher = GamepadControlLauncher()

    # Display available robots
    print("=" * 60)
    print("ROBOTIC ARM TELEOPERATION SYSTEM")
    print("=" * 60)
    print("Available robots:")

    for i, robot in enumerate(launcher.available_robots, 1):
        info = launcher.get_robot_info(robot)
        if info:
            print(f"  {i}. {robot.upper()} - {info['description']}")

    print("\nUsage options:")
    print("  1. Run directly: python gamepad_control.py [robot_name]")
    print("  2. Run interactively: python gamepad_control.py")
    print("=" * 60)

    # Check for command line argument
    if len(sys.argv) > 1:
        # Use command line argument
        robot_name = sys.argv[1].lower()
    else:
        # Interactive selection
        try:
            print("\nSelect a robot:")
            for i, robot in enumerate(launcher.available_robots, 1):
                info = launcher.get_robot_info(robot)
                print(f"  {i}. {robot.upper()}")

            choice = input(f"\nEnter choice (1-{len(launcher.available_robots)}): ").strip()
            if choice.isdigit():
                index = int(choice) - 1
                if 0 <= index < len(launcher.available_robots):
                    robot_name = launcher.available_robots[index]
                else:
                    print("Invalid choice. Using default (panda).")
                    robot_name = 'panda'
            else:
                print("Invalid input. Using default (panda).")
                robot_name = 'panda'

        except (KeyboardInterrupt, EOFError):
            print("\nOperation cancelled.")
            return

    # Validate and run
    if launcher.select_robot(robot_name):
        if launcher.initialize_teleop_system():
            launcher.run()
        else:
            print("Failed to initialize teleoperation system.")
    else:
        print("Robot selection failed.")


if __name__ == "__main__":
    main()



generic_ik_solver.py:

"""
Generic velocity-based inverse kinematics solver.
Uses damped least squares for stable joint-space trajectories.
"""

import numpy as np
import mujoco
from scipy.spatial.transform import Rotation as R


class GenericVelocityIKSolver:
    """Inverse kinematics solver using Jacobian pseudo-inverse method."""

    def __init__(self, model, data, end_effector_body, arm_joint_count=None):
        """
        @brief Initialize IK solver for specified end effector
        @param model: MuJoCo model object
        @param data: MuJoCo data object
        @param end_effector_body: Name of end effector body
        @param arm_joint_count: Number of arm joints for IK
        """
        self.model, self.data = model, data

        # Get end-effector body ID
        self.ee_body_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_BODY, end_effector_body)
        if self.ee_body_id == -1:
            raise ValueError(f"End effector body '{end_effector_body}' not found")

        # Find revolute joints for IK control
        all_joint_indices = [i for i in range(model.njnt)
                           if model.jnt_type[i] == mujoco.mjtJoint.mjJNT_HINGE]

        self.arm_joint_count = min(arm_joint_count, len(all_joint_indices)) if arm_joint_count else len(all_joint_indices)
        self.joint_indices = all_joint_indices[:self.arm_joint_count]
        self.n_joints = len(self.joint_indices)

        # IK parameters
        self.damping, self.max_step_size = 0.01, 0.1

    def solve(self, target_pos, target_quat, max_iterations=50, tolerance=1e-3):
        """
        @brief Solve IK for target end-effector pose
        @param target_pos: Target position (3D vector)
        @param target_quat: Target orientation quaternion [w,x,y,z]
        @return: Tuple of (joint positions, success flag)
        """
        if self.n_joints == 0:
            return np.array([]), False

        original_qpos = self.data.qpos.copy()
        success = False

        for iteration in range(max_iterations):
            mujoco.mj_forward(self.model, self.data)

            # Current pose and errors
            current_pos = self.data.xpos[self.ee_body_id].copy()
            current_quat = self.data.xquat[self.ee_body_id].copy()

            pos_error = target_pos - current_pos

            current_rot = R.from_quat([current_quat[1], current_quat[2], current_quat[3], current_quat[0]])
            target_rot = R.from_quat([target_quat[1], target_quat[2], target_quat[3], target_quat[0]])
            orient_error = (target_rot * current_rot.inv()).as_rotvec()

            error = np.concatenate([pos_error, orient_error])
            error_norm = np.linalg.norm(error)

            if error_norm < tolerance:
                success = True
                break

            # Compute Jacobian
            jac_pos, jac_rot = np.zeros((3, self.model.nv)), np.zeros((3, self.model.nv))
            mujoco.mj_jacBody(self.model, self.data, jac_pos, jac_rot, self.ee_body_id)
            jacobian = np.vstack([jac_pos, jac_rot])

            # Extract controllable joints
            jacobian_reduced = np.zeros((6, self.n_joints))
            for i, joint_id in enumerate(self.joint_indices):
                dof_adr = self.model.jnt_dofadr[joint_id]
                jacobian_reduced[:, i] = jacobian[:, dof_adr]

            # Damped least squares solution
            jacobian_t = jacobian_reduced.T
            jjt = jacobian_reduced @ jacobian_t
            damping_matrix = self.damping * np.eye(6)

            try:
                lambda_matrix = jjt + damping_matrix
                jacobian_pinv = jacobian_t @ np.linalg.pinv(lambda_matrix)
                delta_q = jacobian_pinv @ error

                # Limit step size and apply
                step_norm = np.linalg.norm(delta_q)
                if step_norm > self.max_step_size:
                    delta_q = delta_q * (self.max_step_size / step_norm)

                for i, joint_id in enumerate(self.joint_indices):
                    self.data.qpos[joint_id] += delta_q[i]
                    if self.model.jnt_limited[joint_id]:
                        qmin, qmax = self.model.jnt_range[joint_id]
                        self.data.qpos[joint_id] = np.clip(self.data.qpos[joint_id], qmin, qmax)
            except np.linalg.LinAlgError:
                # Fallback for singularities
                damping_matrix = 0.1 * np.eye(6)
                lambda_matrix = jjt + damping_matrix
                jacobian_pinv = jacobian_t @ np.linalg.pinv(lambda_matrix)
                delta_q = jacobian_pinv @ error * 0.1

                for i, joint_id in enumerate(self.joint_indices):
                    self.data.qpos[joint_id] += delta_q[i]

        # Get final joint positions and restore state
        final_joint_pos = self.data.qpos[self.joint_indices].copy()
        self.data.qpos[:] = original_qpos
        mujoco.mj_forward(self.model, self.data)

        return final_joint_pos, success




genericteleoperation.py:

"""
Main teleoperation module for Panda and UR5 robots.
Handles gamepad input processing and IK solving.
"""

import pygame
import numpy as np
from simulation import Simulation
from generic_ik_solver import GenericVelocityIKSolver
from movement_helper import MovementHelper
from config import get_movement_scales, get_robot_config


class GenericTeleoperation:
    """
    Teleoperation system for Panda and UR5 robotic arms.
    Provides complete 6DOF control using inverse kinematics.
    """

    def __init__(self, robot_name='panda'):
        """
        @brief Initialize teleoperation system for specified robot
        @param robot_name: Name of the robot ('panda' or 'ur5')
        """
        self.robot_name = robot_name
        self.running = False
        self.sim = None
        self.joystick = None
        self.movement = None
        self.ik_solver = None

        # Control state
        self.filtered_twist = np.zeros(6)
        self.gripper_state = "closed"
        self.last_a_state = False

        # Get robot configuration
        self.robot_config = get_robot_config(robot_name)
        self.scales = get_movement_scales(robot_name)

    def initialize_systems(self):
        """@brief Initialize all required systems (simulation, controllers, etc.)"""
        print(f"Initializing teleoperation for {self.robot_name}...")

        # Initialize pygame and gamepad
        pygame.init()
        pygame.joystick.init()

        if pygame.joystick.get_count() == 0:
            raise RuntimeError("No gamepad detected!")

        self.joystick = pygame.joystick.Joystick(0)
        self.joystick.init()
        print(f"Gamepad connected: {self.joystick.get_name()}")

        # Initialize simulation
        self.sim = Simulation(robot_name=self.robot_name, show_viewer=True)

        # Get end effector and initialize systems
        ee_body = self.robot_config['end_effector_body']
        initial_pos, initial_quat = self.sim.get_object_state(ee_body)

        self.movement = MovementHelper(self.sim, robot_name=self.robot_name,
                                      dt=self.sim.model.opt.timestep)
        self.movement.set_initial_pose(initial_pos, initial_quat)

        self.ik_solver = GenericVelocityIKSolver(self.sim.model, self.sim.data, ee_body,
                                               self.robot_config.get('arm_joint_count'))

        print("All systems initialized successfully")
        return True

    def remap_twist(self, twist):
        """
        @brief Apply robot-specific axis remapping to twist command
        @param twist: Original twist command [vx, vy, vz, roll, pitch, yaw]
        @return: Remapped twist command
        """
        remap_rules = self.robot_config.get('axis_remap', {})

        if not remap_rules:
            return twist.copy()

        vx, vy, vz, roll, pitch, yaw = twist

        # Available values for remapping
        values = {
            'vx': vx, 'vy': vy, 'vz': vz, 'roll': roll, 'pitch': pitch, 'yaw': yaw,
            '-vx': -vx, '-vy': -vy, '-vz': -vz, '-roll': -roll, '-pitch': -pitch, '-yaw': -yaw,
            '0': 0.0
        }

        # Apply remapping rules
        return np.array([
            values.get(remap_rules.get('vx', 'vx'), 0),
            values.get(remap_rules.get('vy', 'vy'), 0),
            values.get(remap_rules.get('vz', 'vz'), 0),
            values.get(remap_rules.get('roll', 'roll'), 0),
            values.get(remap_rules.get('pitch', 'pitch'), 0),
            values.get(remap_rules.get('yaw', 'yaw'), 0)
        ])

    def get_twist_from_gamepad(self):
        """
        @brief Convert gamepad inputs to end-effector twist commands
        @return: Tuple of (twist_command, start_button, a_button_state)
        """
        DEADZONE_THRESHOLD = self.scales['deadzone_threshold']

        def deadzone(value):
            return 0.0 if abs(value) < DEADZONE_THRESHOLD else value

        # Joystick inputs with deadzone
        left_x = deadzone(-self.joystick.get_axis(0))
        left_y = deadzone(self.joystick.get_axis(1))
        right_x = deadzone(-self.joystick.get_axis(2))
        right_y = deadzone(self.joystick.get_axis(3))

        # Button states
        l1, r1 = self.joystick.get_button(4), self.joystick.get_button(5)
        start, a_button = self.joystick.get_button(7), self.joystick.get_button(0)

        # Trigger inputs
        l2_raw, r2_raw = (self.joystick.get_axis(4) + 1) / 2, (self.joystick.get_axis(5) + 1) / 2
        l2 = 0.0 if l2_raw < DEADZONE_THRESHOLD else l2_raw
        r2 = 0.0 if r2_raw < DEADZONE_THRESHOLD else r2_raw

        # Twist components
        vx = right_y * self.scales['translation']   # Forward/backward
        vy = left_x * self.scales['translation']    # Left/right
        vz = left_y * self.scales['translation']    # Up/down

        # Handle SO100 case if somehow selected (though this class is for Panda/UR5)
        roll = 0.0 if self.robot_name == 'so100' else right_x * self.scales['rotation']
        pitch = (r1 - l1) * self.scales['tilt']     # Pitch from shoulder buttons
        yaw = (r2 - l2) * self.scales['rotation']   # Yaw from triggers

        twist = np.array([vx, vy, vz, roll, pitch, yaw])
        return self.remap_twist(twist), start, a_button

    def process_movement(self, twist_command):
        """
        @brief Process movement command using inverse kinematics
        @param twist_command: Twist command for end-effector movement
        """
        # Apply low-pass filter for smooth movement
        alpha = 0.3  # Smoothing factor
        self.filtered_twist = (1 - alpha) * self.filtered_twist + alpha * twist_command

        if np.linalg.norm(self.filtered_twist) > 0.01:
            try:
                # Integrate twist to get target pose
                target_pos, target_quat = self.movement.integrate_twist(self.filtered_twist)

                # Solve inverse kinematics for arm joints
                target_joint_pos, success = self.ik_solver.solve(target_pos, target_quat)

                if success:
                    # Apply joint positions to simulation
                    n_arm_joints = len(target_joint_pos)
                    actual_joints = min(n_arm_joints, len(self.sim.data.ctrl))
                    self.sim.data.ctrl[:actual_joints] = target_joint_pos[:actual_joints]
                else:
                    print("IK solution failed to converge")
            except Exception as e:
                print(f"Movement/IK error: {e}")

    def process_gripper(self, a_button):
        """
        @brief Process gripper control input
        @param a_button: Current state of A button
        """
        GRIPPER_OPEN_POS = self.scales['gripper_open_pos']
        GRIPPER_CLOSE_POS = self.scales['gripper_close_pos']
        GRIPPER_SPEED = self.scales['gripper_speed']

        # Gripper toggle on A button press
        if a_button and not self.last_a_state:
            if self.gripper_state == "open":
                self.movement.move_gripper(GRIPPER_CLOSE_POS, GRIPPER_SPEED)
                self.gripper_state = "closed"
                print("Gripper closing")
            else:
                self.movement.move_gripper(GRIPPER_OPEN_POS, GRIPPER_SPEED)
                self.gripper_state = "open"
                print("Gripper opening")

        self.last_a_state = a_button
        self.movement.update_gripper()

    def run(self):
        """@brief Main teleoperation loop"""
        if not self.initialize_systems():
            return

        self.running = True
        print(f"{self.robot_name.upper()} Teleoperation active. Press START to exit.")

        try:
            while self.running:
                # Process pygame events
                for event in pygame.event.get():
                    if event.type == pygame.QUIT:
                        self.running = False

                # Get gamepad input
                twist, start, a_button = self.get_twist_from_gamepad()

                # Exit on START button
                if start:
                    print("Exiting teleoperation...")
                    break

                # Process movement and gripper commands
                self.process_movement(twist)
                self.process_gripper(a_button)

                # Advance simulation
                self.sim.step()

        except KeyboardInterrupt:
            print("Teleoperation interrupted by user")
        except Exception as e:
            print(f"Error in teleoperation loop: {e}")
        finally:
            self.cleanup()

    def cleanup(self):
        """@brief Clean up resources"""
        print("Cleaning up resources...")
        if self.sim and self.sim.show_viewer:
            self.sim.viewer.close()
        pygame.quit()
        print("Teleoperation ended.")


def main():
    """@brief Main function to start teleoperation"""
    # Choose between Panda and UR5 here
    robot_name = 'panda'  # Options: 'panda', 'ur5'

    # Create and run teleoperation system
    teleop_system = GenericTeleoperation(robot_name)
    teleop_system.run()


if __name__ == "__main__":
    main()




movement_helper.py:

"""
Movement helper for pose integration and gripper control.
Handles smooth movement calculations for teleoperation.
"""

import numpy as np
from scipy.spatial.transform import Rotation as R
from config import get_robot_config  # Updated import


class MovementHelper:
    """Handles pose integration and movement calculations."""

    def __init__(self, sim, robot_name, dt=0.002, max_linear_speed=0.1, max_angular_speed=0.5):
        """
        @brief Initialize movement helper with stability settings
        @param sim: Simulation instance
        @param robot_name: Name of the robot for configuration
        @param dt: Time step for integration
        @param max_linear_speed: Maximum linear speed
        @param max_angular_speed: Maximum angular speed
        """
        self.sim = sim
        self.robot_name = robot_name  # Store robot name
        self.dt = dt
        self.max_linear_speed = max_linear_speed
        self.max_angular_speed = max_angular_speed

        self.gripper_control_indices = self._find_gripper_controls()
        self.gripper_target, self.gripper_speed = 0.0, 255.0  # Start closed
        self.target_pos, self.target_quat = None, None

    def _find_gripper_controls(self):
        """@brief Find control indices for gripper actuators"""
        gripper_indices = []

        for i in range(self.sim.model.nu):
            # Extract actuator name
            name_id = self.sim.model.name_actuatoradr[i]
            name_bytes = bytearray()
            j = name_id
            while j < len(self.sim.model.names) and self.sim.model.names[j] != 0:
                name_bytes.append(self.sim.model.names[j])
                j += 1
            act_name = name_bytes.decode('utf-8') if name_bytes else f"actuator_{i}"

            # Robot-specific gripper detection
            if self.robot_name == 'so100':  # Use stored robot name
                if 'Jaw' in act_name:
                    gripper_indices.append(i)
            else:
                if any(keyword in act_name.lower() for keyword in ['finger', 'gripper', 'hand']):
                    gripper_indices.append(i)

        # Default to last actuator if none found
        if not gripper_indices:
            gripper_indices = [self.sim.model.nu - 1]

        return gripper_indices


    def set_initial_pose(self, pos, quat):
        """
        @brief Set initial end-effector pose
        @param pos: Initial position
        @param quat: Initial orientation quaternion
        """
        self.target_pos = np.array(pos, dtype=np.float64)
        self.target_quat = np.array(quat, dtype=np.float64)

    def integrate_twist(self, twist_command):
        """
        @brief Integrate twist command to update target pose
        @param twist_command: [vx, vy, vz, wx, wy, wz] in end-effector frame
        @return: New position and orientation
        """
        if self.target_pos is None or self.target_quat is None:
            raise ValueError("Initial pose not set")

        # Apply speed limits
        linear_vel = np.array(twist_command[:3])
        angular_vel = np.array(twist_command[3:])

        linear_speed = np.linalg.norm(linear_vel)
        if linear_speed > self.max_linear_speed:
            linear_vel = linear_vel * (self.max_linear_speed / linear_speed)

        angular_speed = np.linalg.norm(angular_vel)
        if angular_speed > self.max_angular_speed:
            angular_vel = angular_vel * (self.max_angular_speed / angular_speed)

        # Convert current orientation
        current_rot = R.from_quat([self.target_quat[1], self.target_quat[2],
                                   self.target_quat[3], self.target_quat[0]])

        # Transform velocities to world frame
        linear_vel_world = current_rot.apply(linear_vel)
        new_pos = self.target_pos + linear_vel_world * self.dt

        # Update orientation
        if np.linalg.norm(angular_vel) > 1e-6:
            angular_vel_world = current_rot.apply(angular_vel)
            delta_angle = angular_vel_world * self.dt
            delta_rotation = R.from_rotvec(delta_angle)
            new_rot = delta_rotation * current_rot
            new_quat_scipy = new_rot.as_quat()  # [x, y, z, w]
            new_quat = np.array([new_quat_scipy[3], new_quat_scipy[0],
                                 new_quat_scipy[1], new_quat_scipy[2]])  # [w, x, y, z]
        else:
            new_quat = self.target_quat.copy()

        # Normalize and update
        new_quat /= np.linalg.norm(new_quat)
        self.target_pos, self.target_quat = new_pos, new_quat

        return new_pos, new_quat

    def get_target_pose(self):
        """@brief Get current target pose"""
        return self.target_pos, self.target_quat

    def move_gripper(self, gripper_pos, speed):
        """
        @brief Set target gripper position and speed
        @param gripper_pos: Target position (0=closed, 1=open)
        @param speed: Movement speed (0-1 scale)
        """
        max_speed = 255.0  # Units per second
        self.gripper_target = np.clip(gripper_pos * 255, 0, 255)
        self.gripper_speed = np.clip(speed * max_speed, 0, max_speed)

    def update_gripper(self):
        """@brief Update gripper position towards target"""
        if not self.gripper_control_indices:
            return

        for control_index in self.gripper_control_indices:
            if control_index >= len(self.sim.data.ctrl):
                continue

            current_pos = self.sim.data.ctrl[control_index]
            delta = self.gripper_target - current_pos

            if abs(delta) < 0.1:
                continue

            step_size = self.gripper_speed * self.sim.model.opt.timestep
            new_pos = (self.gripper_target if abs(delta) <= step_size
                       else current_pos + np.sign(delta) * step_size)

            self.sim.data.ctrl[control_index] = new_pos




simulation.py:

"""
MuJoCo simulation wrapper for robotic arm teleoperation.
Provides simulation environment and object manipulation utilities.
"""

import mujoco
import mujoco.viewer
import time
import numpy as np
from config import get_robot_config


class Simulation:
    """MuJoCo simulation class for robotic arm teleoperation."""

    def __init__(self, robot_name, show_viewer=True):  # Add robot_name parameter
        """
        @brief Initialize the simulation with a model and viewer settings
        @param robot_name: Name of the robot to use ('panda', 'ur5', 'so100')
        @param show_viewer: Whether to display the visualizer
        """
        # Load robot-specific configuration
        self.config = robot_name  # Use passed robot name

        # Robot configurations with initial positions/controls
        configs = {
            "panda": {
                "world": "franka_emika_panda/demo_scene.xml",
                "qpos": [0.075, -0.798, -0.047, -2.335, -0.033, 1.529, 0.826, 0.0, 0.0, 0.39, 0.0, 0.013, 1.0, 0.0, 0.0, 0.0],
                "ctrl": [0.075, -0.88, -0.046, -2.328, -0.033, 1.530, 0.826, 0.0]
            },
            "ur5": {
                "world": "universal_robots_ur5e/scene.xml",
                "qpos": [-0.281, -1.192, 1.826, 0.976, 1.574, -0.284, 0.0, 0.39, 0.0, 0.013, 1.0, 0.0, 0.0, 0.0, 0.39, 0, 0.018, 0, 0, 0, 0],
                "ctrl": [-0.305, -1.56, 1.9, 1.23, 1.57, -0.305, 0]
            },
            "so100": {
                "world": "trs_so_arm100/scene.xml",
                "qpos": [0.0, -1.57, 1.57, 1.57, -1.57, 0.0],
                "ctrl": [0.0, -1.57, 1.57, 1.57, -1.57, 0.0]
            }
        }

        # Validate and load configuration
        if self.config not in configs:
            raise ValueError(f"Unknown robot configuration: {self.config}")

        config = configs[self.config]
        self.model = mujoco.MjModel.from_xml_path(config["world"])
        self.data = mujoco.MjData(self.model)

        # Set initial state
        qpos, ctrl = config["qpos"], config["ctrl"]
        self.data.qpos[:min(len(qpos), self.model.nq)] = qpos[:self.model.nq]
        self.data.ctrl[:min(len(ctrl), self.model.nu)] = ctrl[:self.model.nu]

        mujoco.mj_step(self.model, self.data, nstep=100)

        # Viewer setup
        self.show_viewer = show_viewer
        self.step_count = 0

        if show_viewer:
            self.viewer = mujoco.viewer.launch_passive(self.model, self.data)
            self.viewer_freq = 60
            self.viewer_interval = 1.0 / self.viewer_freq
            self.viewer_nth = int(1 / (self.model.opt.timestep * self.viewer_freq))
            self.wall_start_time = time.time()


    def step(self):
        """
        @brief Advance simulation by one step with real-time synchronization
        """
        mujoco.mj_step(self.model, self.data, nstep=1)
        self.step_count += 1

        # Real-time synchronization for viewer
        if self.show_viewer:
            t_sim, t_wall = self.data.time, time.time() - self.wall_start_time
            if t_sim - t_wall > 0:
                time.sleep(t_sim - t_wall)
            if self.step_count % self.viewer_nth == 0:
                self.viewer.sync()

    def get_object_state(self, body_name):
        """
        @brief Get world-frame position and orientation of a body
        @param body_name: Name of the body to query
        @return: Tuple of (position, quaternion) arrays
        """
        # Find body ID
        bid = mujoco.mj_name2id(self.model, mujoco.mjtObj.mjOBJ_BODY, body_name)
        if bid < 0:
            raise KeyError(f"Body '{body_name}' not found")

        # Try to find free joint for direct access
        for j in range(self.model.njnt):
            if (self.model.jnt_bodyid[j] == bid and
                self.model.jnt_type[j] == mujoco.mjtJoint.mjJNT_FREE):
                adr = self.model.jnt_qposadr[j]
                return (self.data.qpos[adr:adr+3].copy(),
                        self.data.qpos[adr+3:adr+7].copy())

        # Fallback to cached pose
        return self.data.xpos[bid].copy(), self.data.xquat[bid].copy()





so100_ik_solver.py:

"""
Specialized IK solver for SO100 5DOF arm with joint preservation.
Preserves manually controlled joints while solving for position.
"""

import numpy as np
import mujoco


class SO100IKSolver:
    """5DOF IK solver that preserves manually controlled joints."""

    def __init__(self, model, data, end_effector_body, joint_controller):
        """
        @brief Initialize IK solver for SO100
        @param model: MuJoCo model object
        @param data: MuJoCo data object
        @param end_effector_body: Name of end effector body
        @param joint_controller: SO100Teleoperation instance for joint mapping
        """
        self.model, self.data = model, data
        self.joint_controller = joint_controller

        # Get end-effector body ID
        self.ee_body_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_BODY, end_effector_body)
        if self.ee_body_id == -1:
            raise ValueError(f"End effector body '{end_effector_body}' not found")

        self._build_joint_mapping()

        # IK parameters
        self.damping, self.max_step_size = 0.01, 0.1

    def _build_joint_mapping(self):
        """@brief Build mapping between joint names and their qpos indices"""
        self.joint_qpos_indices = {}

        for i in range(self.model.njnt):
            # Extract joint name
            name_id = self.model.name_jntadr[i]
            name_bytes = bytearray()
            j = name_id
            while j < len(self.model.names) and self.model.names[j] != 0:
                name_bytes.append(self.model.names[j])
                j += 1
            joint_name = name_bytes.decode('utf-8') if name_bytes else f"joint_{i}"

            # Map identifiable joints
            if 'Rotation' in joint_name:
                self.joint_qpos_indices['rotation'] = i
            elif 'Pitch' in joint_name and 'Wrist' not in joint_name:
                self.joint_qpos_indices['pitch'] = i  # Shoulder pitch
            elif 'Elbow' in joint_name:
                self.joint_qpos_indices['elbow'] = i
            elif 'Wrist_Pitch' in joint_name:
                self.joint_qpos_indices['wrist_pitch'] = i
            elif 'Wrist_Roll' in joint_name:
                self.joint_qpos_indices['wrist_roll'] = i

        # Define control strategy
        self.position_joints = ['pitch', 'elbow']  # For horizontal/vertical movement
        self.manual_joints = ['rotation', 'wrist_pitch', 'wrist_roll']  # Manual control

    def solve_position_only(self, target_pos, fixed_rotation=None, fixed_wrist_roll=None,
                           fixed_wrist_pitch=None, max_iterations=50, tolerance=1e-3):
        """
        @brief Solve IK for position only while preserving manual joints
        @param target_pos: Target position (3D)
        @param fixed_rotation: Fixed rotation joint value
        @param fixed_wrist_roll: Fixed wrist roll value
        @param fixed_wrist_pitch: Fixed wrist pitch value
        @return: Tuple of (position_joint_values, success)
        """
        original_qpos = self.data.qpos.copy()
        success = False

        # Use current values if fixed values not provided
        if fixed_rotation is None and 'rotation' in self.joint_qpos_indices:
            fixed_rotation = self.data.qpos[self.joint_qpos_indices['rotation']]
        if fixed_wrist_roll is None and 'wrist_roll' in self.joint_qpos_indices:
            fixed_wrist_roll = self.data.qpos[self.joint_qpos_indices['wrist_roll']]
        if fixed_wrist_pitch is None and 'wrist_pitch' in self.joint_qpos_indices:
            fixed_wrist_pitch = self.data.qpos[self.joint_qpos_indices['wrist_pitch']]

        for iteration in range(max_iterations):
            # Apply fixed joint values
            if fixed_rotation is not None and 'rotation' in self.joint_qpos_indices:
                self.data.qpos[self.joint_qpos_indices['rotation']] = fixed_rotation
            if fixed_wrist_roll is not None and 'wrist_roll' in self.joint_qpos_indices:
                self.data.qpos[self.joint_qpos_indices['wrist_roll']] = fixed_wrist_roll
            if fixed_wrist_pitch is not None and 'wrist_pitch' in self.joint_qpos_indices:
                self.data.qpos[self.joint_qpos_indices['wrist_pitch']] = fixed_wrist_pitch

            mujoco.mj_forward(self.model, self.data)

            # Position error calculation
            current_pos = self.data.xpos[self.ee_body_id].copy()
            pos_error = target_pos - current_pos
            error_norm = np.linalg.norm(pos_error)

            if error_norm < tolerance:
                success = True
                break

            # Jacobian for position control
            jac_pos = np.zeros((3, self.model.nv))
            mujoco.mj_jacBody(self.model, self.data, jac_pos, None, self.ee_body_id)

            # Extract controllable joints
            controllable_joints = []
            for joint_name in self.position_joints:
                if joint_name in self.joint_qpos_indices:
                    joint_id = self.joint_qpos_indices[joint_name]
                    dof_adr = self.model.jnt_dofadr[joint_id]
                    controllable_joints.append(dof_adr)

            if not controllable_joints:
                break

            jacobian_reduced = jac_pos[:, controllable_joints]

            # Damped least squares solution
            jacobian_t = jacobian_reduced.T
            jjt = jacobian_reduced @ jacobian_t
            damping_matrix = self.damping * np.eye(3)

            try:
                lambda_matrix = jjt + damping_matrix
                jacobian_pinv = jacobian_t @ np.linalg.pinv(lambda_matrix)
                delta_q = jacobian_pinv @ pos_error

                # Limit step size
                step_norm = np.linalg.norm(delta_q)
                if step_norm > self.max_step_size:
                    delta_q = delta_q * (self.max_step_size / step_norm)

                # Apply to position joints with limits
                for i, dof_adr in enumerate(controllable_joints):
                    for joint_name, qpos_idx in self.joint_qpos_indices.items():
                        if joint_name in self.position_joints:
                            joint_dof_adr = self.model.jnt_dofadr[qpos_idx]
                            if joint_dof_adr == dof_adr:
                                self.data.qpos[qpos_idx] += delta_q[i]
                                if self.model.jnt_limited[qpos_idx]:
                                    qmin, qmax = self.model.jnt_range[qpos_idx]
                                    self.data.qpos[qpos_idx] = np.clip(self.data.qpos[qpos_idx], qmin, qmax)
                                break
            except np.linalg.LinAlgError:
                break

        # Get final position joint values
        position_joint_values = {}
        for joint_name in self.position_joints:
            if joint_name in self.joint_qpos_indices:
                position_joint_values[joint_name] = self.data.qpos[self.joint_qpos_indices[joint_name]]

        # Restore original state
        self.data.qpos[:] = original_qpos
        mujoco.mj_forward(self.model, self.data)

        return position_joint_values, success




so100teleoperation.py:

"""
SO100-specific teleoperation with hybrid control scheme.
Uses joint control for rotations, IK for translations.
"""

import pygame
import numpy as np
from simulation import Simulation
from movement_helper import MovementHelper
from config import get_movement_scales, get_joint_multipliers, get_robot_config
from so100_ik_solver import SO100IKSolver
import mujoco


class SO100Teleoperation:
    """
    SO100-specific teleoperation system with hybrid control.
    Uses joint control for rotations and IK for translations.
    """

    def __init__(self):
        """@brief Initialize SO100 teleoperation system"""
        self.robot_name = 'so100'
        self.running = False
        self.sim = None
        self.joystick = None
        self.joint_controller = None
        self.movement = None
        self.ik_solver = None

        # Control state
        self.gripper_state = "closed"
        self.last_a_state = False

        # Get robot configuration
        self.robot_config = get_robot_config(self.robot_name)
        self.scales = get_movement_scales(self.robot_name)

    def initialize_systems(self):
        """@brief Initialize all required systems"""
        print("Initializing SO100 teleoperation...")

        # Initialize pygame and gamepad
        pygame.init()
        pygame.joystick.init()

        if pygame.joystick.get_count() == 0:
            raise RuntimeError("No gamepad detected!")

        self.joystick = pygame.joystick.Joystick(0)
        self.joystick.init()
        print(f"Gamepad connected: {self.joystick.get_name()}")

        # Initialize simulation
        self.sim = Simulation(robot_name=self.robot_name, show_viewer=True)

        # Initialize joint controller
        self.joint_controller = SO100JointController(self.sim)

        # Initialize IK and movement systems
        ee_body = self.robot_config['end_effector_body']
        self.ik_solver = SO100IKSolver(self.sim.model, self.sim.data, ee_body, self.joint_controller)

        initial_pos, initial_quat = self.sim.get_object_state(ee_body)
        self.movement = MovementHelper(self.sim, robot_name=self.robot_name,
                                      dt=self.sim.model.opt.timestep)
        self.movement.set_initial_pose(initial_pos, initial_quat)

        print("SO100 systems initialized successfully")
        return True

    def get_input_from_gamepad(self):
        """
        @brief Get modified input structure for SO100 pure translational control
        @return: Dictionary of input values
        """
        DEADZONE_THRESHOLD = self.scales['deadzone_threshold']

        def deadzone(value):
            return 0.0 if abs(value) < DEADZONE_THRESHOLD else value

        # Get raw inputs with deadzone filtering
        left_y = deadzone(self.joystick.get_axis(1))    # Left stick vertical (pure Z)
        right_y = deadzone(self.joystick.get_axis(3))   # Right stick vertical (horizontal in/out)
        left_x = deadzone(-self.joystick.get_axis(0))   # Left stick horizontal (rotation)

        # Button states for joint control
        l1, r1 = self.joystick.get_button(4), self.joystick.get_button(5)
        l2_raw, r2_raw = (self.joystick.get_axis(4) + 1) / 2, (self.joystick.get_axis(5) + 1) / 2
        l2 = 0.0 if l2_raw < DEADZONE_THRESHOLD else l2_raw
        r2 = 0.0 if r2_raw < DEADZONE_THRESHOLD else r2_raw

        return {
            'right_y': right_y,      # Horizontal in/out relative to base
            'left_y': left_y,        # Pure vertical movement
            'left_x': left_x,        # Rotation joint control
            'l1': l1, 'r1': r1,      # Wrist pitch
            'l2': l2, 'r2': r2,      # Wrist roll
            'start': self.joystick.get_button(7),
            'a_button': self.joystick.get_button(0)
        }

    def process_joint_control(self, input_data):
        """@brief Process joint-space control for manual joints"""
        self.joint_controller.control_rotation_joint(input_data['left_x'])
        self.joint_controller.control_wrist_roll(input_data['l2'], input_data['r2'])
        self.joint_controller.control_wrist_pitch(input_data['l1'], input_data['r1'])

    def process_translation_control(self, input_data):
        """@brief Process translational control using IK - skip if rotation is active"""
        # Skip translation if rotation input is significant (Direct joint control and IK are conflicting, leading to jumps of the robot. Hence, only either translational movement or Rotation of robot at same time allowed)
        if abs(input_data['left_x']) > 0.2:  # Add a small threshold
            return  # Ignore translation when rotating

        if abs(input_data['right_y']) > 0.01 or abs(input_data['left_y']) > 0.01:
            ee_body = self.robot_config['end_effector_body']
            current_pos, current_quat = self.sim.get_object_state(ee_body)

            target_pos = self.calculate_pure_translation(
                current_pos, input_data['right_y'], input_data['left_y'],
                self.scales['translation'], self.sim.model.opt.timestep
            )

            # Preserve manual joint values
            current_rotation = self.sim.data.ctrl[self.joint_controller.joint_map['rotation']]
            current_wrist_roll = self.sim.data.ctrl[self.joint_controller.joint_map['wrist_roll']]
            current_wrist_pitch = self.sim.data.ctrl[self.joint_controller.joint_map['wrist_pitch']]

            # Solve IK for position only
            position_joint_values, success = self.ik_solver.solve_position_only(
                target_pos, current_rotation, current_wrist_roll, current_wrist_pitch
            )

            if success:
                for joint_name, joint_value in position_joint_values.items():
                    if joint_name in self.joint_controller.joint_map:
                        self.sim.data.ctrl[self.joint_controller.joint_map[joint_name]] = joint_value

    def calculate_pure_translation(self, current_pos, right_y, left_y, translation_scale, dt):
        """
        @brief Calculate target position using Rotation joint as reference
        @param current_pos: Current end-effector position
        @param right_y: Right stick Y input (horizontal movement)
        @param left_y: Left stick Y input (vertical movement)
        @param translation_scale: Movement scaling factor
        @param dt: Time step
        @return: Target position array
        """
        target_pos = np.array(current_pos, dtype=np.float64)

        # Get Rotation joint as reference point
        rotation_joint_pos = self.get_rotation_joint_position()

        # Horizontal movement along radial direction from rotation joint
        if abs(right_y) > 0.01:
            horizontal_vec = np.array([current_pos[0] - rotation_joint_pos[0],
                                     current_pos[1] - rotation_joint_pos[1]])
            horizontal_dist = np.linalg.norm(horizontal_vec)

            if horizontal_dist > 0.001:
                horizontal_dir = horizontal_vec / horizontal_dist
                movement = right_y * translation_scale * dt * 50
                target_pos[0] += horizontal_dir[0] * movement
                target_pos[1] += horizontal_dir[1] * movement
            else:
                target_pos[0] += right_y * translation_scale * dt * 50

        # Pure vertical movement
        if abs(left_y) > 0.01:
            target_pos[2] += -left_y * translation_scale * dt * 50

        return target_pos

    def get_rotation_joint_position(self):
        """
        @brief Get world position of Rotation joint for reference
        @return: Position array [x, y, z]
        """
        # Try different methods to find rotation joint position
        rotation_body_id = mujoco.mj_name2id(self.sim.model, mujoco.mjtObj.mjOBJ_BODY, "Rotation_Pitch")
        if rotation_body_id != -1:
            return self.sim.data.xpos[rotation_body_id].copy()

        rotation_joint_id = mujoco.mj_name2id(self.sim.model, mujoco.mjtObj.mjOBJ_JOINT, "Rotation")
        if rotation_joint_id != -1:
            body_id = self.sim.model.jnt_bodyid[rotation_joint_id]
            return self.sim.data.xpos[body_id].copy()

        # Fallback positions
        base_body_id = mujoco.mj_name2id(self.sim.model, mujoco.mjtObj.mjOBJ_BODY, "Base")
        if base_body_id != -1:
            return self.sim.data.xpos[base_body_id].copy()

        return np.array([0.0, 0.0, 0.0])

    def process_gripper(self, a_button):
        """@brief Process gripper control input"""
        GRIPPER_OPEN_POS = self.scales['gripper_open_pos']
        GRIPPER_CLOSE_POS = self.scales['gripper_close_pos']
        GRIPPER_SPEED = self.scales['gripper_speed']

        # Gripper toggle on A button press
        if a_button and not self.last_a_state:
            target_pos = GRIPPER_OPEN_POS if self.gripper_state == "closed" else GRIPPER_CLOSE_POS
            self.movement.move_gripper(target_pos, GRIPPER_SPEED)
            self.gripper_state = "open" if self.gripper_state == "closed" else "closed"
            print(f"Gripper: {self.gripper_state.upper()}")

        self.last_a_state = a_button
        self.movement.update_gripper()

    def run(self):
        """@brief Main teleoperation loop"""
        if not self.initialize_systems():
            return

        self.running = True
        print("SO100 Teleoperation active. Press START to exit.")
        print("Controls:")
        print("  Left Stick X: Rotation joint")
        print("  Left Stick Y: Vertical movement (up/down)")
        print("  Right Stick Y: Horizontal movement (in/out)")
        print("  R1/L1: Wrist pitch")
        print("  R2/L2: Wrist roll")
        print("  A Button: Toggle gripper")

        try:
            while self.running:
                # Process pygame events
                for event in pygame.event.get():
                    if event.type == pygame.QUIT:
                        self.running = False

                # Get input data
                input_data = self.get_input_from_gamepad()

                if input_data['start']:
                    print("Exiting teleoperation...")
                    break

                # Process all control inputs
                self.process_joint_control(input_data)
                self.process_translation_control(input_data)
                self.process_gripper(input_data['a_button'])

                # Advance simulation
                self.sim.step()

        except KeyboardInterrupt:
            print("Teleoperation interrupted by user")
        except Exception as e:
            print(f"Error in teleoperation loop: {e}")
        finally:
            self.cleanup()

    def cleanup(self):
        """@brief Clean up resources"""
        print("Cleaning up resources...")
        if self.sim and self.sim.show_viewer:
            self.sim.viewer.close()
        pygame.quit()
        print("SO100 teleoperation ended.")


class SO100JointController:
    """Joint-space controller for SO100-specific movements."""

    def __init__(self, sim):
        """
        @brief Initialize SO100 joint controller
        @param sim: Simulation instance
        """
        self.sim = sim
        self.robot_name = 'so100'
        self.movement_scales = get_movement_scales(self.robot_name)
        self.joint_multipliers = get_joint_multipliers(self.robot_name)
        self.joint_map = self._build_joint_map()

    def _build_joint_map(self):
        """@brief Map joint names to their control indices"""
        joint_map = {}
        for i in range(self.sim.model.nu):
            # Extract actuator name
            name_id = self.sim.model.name_actuatoradr[i]
            name_bytes = bytearray()
            j = name_id
            while j < len(self.sim.model.names) and self.sim.model.names[j] != 0:
                name_bytes.append(self.sim.model.names[j])
                j += 1
            act_name = name_bytes.decode('utf-8') if name_bytes else f"actuator_{i}"

            # Map to expected joints
            if 'Rotation' in act_name:
                joint_map['rotation'] = i
            elif 'Pitch' in act_name and 'Wrist' not in act_name:
                joint_map['pitch'] = i
            elif 'Elbow' in act_name:
                joint_map['elbow'] = i
            elif 'Wrist_Pitch' in act_name:
                joint_map['wrist_pitch'] = i
            elif 'Wrist_Roll' in act_name:
                joint_map['wrist_roll'] = i
            elif 'Jaw' in act_name:
                joint_map['gripper'] = i

        return joint_map

    def control_rotation_joint(self, left_stick_x):
        """
        @brief Control base rotation joint
        @param left_stick_x: Left stick horizontal input
        """
        if 'rotation' in self.joint_map:
            scale = self.movement_scales['rotation'] * self.joint_multipliers['rotation']
            current = self.sim.data.ctrl[self.joint_map['rotation']]
            self.sim.data.ctrl[self.joint_map['rotation']] = current - left_stick_x * scale

    def control_wrist_roll(self, l2, r2):
        """
        @brief Control wrist roll using triggers
        @param l2: Left trigger value
        @param r2: Right trigger value
        """
        if 'wrist_roll' in self.joint_map:
            roll_scale = self.movement_scales['rotation'] * self.joint_multipliers['wrist_roll']
            current = self.sim.data.ctrl[self.joint_map['wrist_roll']]
            delta = (l2 - r2) * roll_scale
            self.sim.data.ctrl[self.joint_map['wrist_roll']] = current + delta

    def control_wrist_pitch(self, l1, r1):
        """
        @brief Control wrist pitch using shoulder buttons
        @param l1: Left shoulder button
        @param r1: Right shoulder button
        """
        if 'wrist_pitch' in self.joint_map:
            pitch_scale = self.movement_scales['tilt'] * self.joint_multipliers['wrist_pitch']
            current = self.sim.data.ctrl[self.joint_map['wrist_pitch']]
            delta = (l1 - r1) * pitch_scale
            self.sim.data.ctrl[self.joint_map['wrist_pitch']] = current + delta


def main():
    """@brief Legacy main function for direct execution"""
    teleop_system = SO100Teleoperation()
    teleop_system.run()


if __name__ == "__main__":
    main()



